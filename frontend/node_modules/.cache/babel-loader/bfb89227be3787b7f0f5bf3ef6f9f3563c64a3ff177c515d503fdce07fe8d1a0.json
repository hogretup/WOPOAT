{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MathML = void 0;\nvar InputJax_js_1 = require(\"../core/InputJax.js\");\nvar Options_js_1 = require(\"../util/Options.js\");\nvar FunctionList_js_1 = require(\"../util/FunctionList.js\");\nvar FindMathML_js_1 = require(\"./mathml/FindMathML.js\");\nvar MathMLCompile_js_1 = require(\"./mathml/MathMLCompile.js\");\nvar MathML = function (_super) {\n  __extends(MathML, _super);\n  function MathML(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = this;\n    var _a = __read((0, Options_js_1.separateOptions)(options, FindMathML_js_1.FindMathML.OPTIONS, MathMLCompile_js_1.MathMLCompile.OPTIONS), 3),\n      mml = _a[0],\n      find = _a[1],\n      compile = _a[2];\n    _this = _super.call(this, mml) || this;\n    _this.findMathML = _this.options['FindMathML'] || new FindMathML_js_1.FindMathML(find);\n    _this.mathml = _this.options['MathMLCompile'] || new MathMLCompile_js_1.MathMLCompile(compile);\n    _this.mmlFilters = new FunctionList_js_1.FunctionList();\n    return _this;\n  }\n  MathML.prototype.setAdaptor = function (adaptor) {\n    _super.prototype.setAdaptor.call(this, adaptor);\n    this.findMathML.adaptor = adaptor;\n    this.mathml.adaptor = adaptor;\n  };\n  MathML.prototype.setMmlFactory = function (mmlFactory) {\n    _super.prototype.setMmlFactory.call(this, mmlFactory);\n    this.mathml.setMmlFactory(mmlFactory);\n  };\n  Object.defineProperty(MathML.prototype, \"processStrings\", {\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MathML.prototype.compile = function (math, document) {\n    var mml = math.start.node;\n    if (!mml || !math.end.node || this.options['forceReparse'] || this.adaptor.kind(mml) === '#text') {\n      var mathml = this.executeFilters(this.preFilters, math, document, (math.math || '<math></math>').trim());\n      var doc = this.checkForErrors(this.adaptor.parse(mathml, 'text/' + this.options['parseAs']));\n      var body = this.adaptor.body(doc);\n      if (this.adaptor.childNodes(body).length !== 1) {\n        this.error('MathML must consist of a single element');\n      }\n      mml = this.adaptor.remove(this.adaptor.firstChild(body));\n      if (this.adaptor.kind(mml).replace(/^[a-z]+:/, '') !== 'math') {\n        this.error('MathML must be formed by a <math> element, not <' + this.adaptor.kind(mml) + '>');\n      }\n    }\n    mml = this.executeFilters(this.mmlFilters, math, document, mml);\n    return this.executeFilters(this.postFilters, math, document, this.mathml.compile(mml));\n  };\n  MathML.prototype.checkForErrors = function (doc) {\n    var err = this.adaptor.tags(this.adaptor.body(doc), 'parsererror')[0];\n    if (err) {\n      if (this.adaptor.textContent(err) === '') {\n        this.error('Error processing MathML');\n      }\n      this.options['parseError'].call(this, err);\n    }\n    return doc;\n  };\n  MathML.prototype.error = function (message) {\n    throw new Error(message);\n  };\n  MathML.prototype.findMath = function (node) {\n    return this.findMathML.findMath(node);\n  };\n  MathML.NAME = 'MathML';\n  MathML.OPTIONS = (0, Options_js_1.defaultOptions)({\n    parseAs: 'html',\n    forceReparse: false,\n    FindMathML: null,\n    MathMLCompile: null,\n    parseError: function parseError(node) {\n      this.error(this.adaptor.textContent(node).replace(/\\n.*/g, ''));\n    }\n  }, InputJax_js_1.AbstractInputJax.OPTIONS);\n  return MathML;\n}(InputJax_js_1.AbstractInputJax);\nexports.MathML = MathML;","map":{"version":3,"names":["InputJax_js_1","require","Options_js_1","FunctionList_js_1","FindMathML_js_1","MathMLCompile_js_1","MathML","_super","__extends","options","_this","_a","__read","separateOptions","FindMathML","OPTIONS","MathMLCompile","mml","find","compile","call","findMathML","mathml","mmlFilters","FunctionList","prototype","setAdaptor","adaptor","setMmlFactory","mmlFactory","Object","defineProperty","get","math","document","start","node","end","kind","executeFilters","preFilters","trim","doc","checkForErrors","parse","body","childNodes","length","error","remove","firstChild","replace","postFilters","err","tags","textContent","message","Error","findMath","NAME","defaultOptions","parseAs","forceReparse","parseError","AbstractInputJax","exports"],"sources":["C:\\Users\\wongkj\\Desktop\\wopoat\\frontend\\node_modules\\mathjax-full\\ts\\input\\mathml.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the MathML InputJax object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AbstractInputJax} from '../core/InputJax.js';\nimport {defaultOptions, separateOptions, OptionList} from '../util/Options.js';\nimport {FunctionList} from '../util/FunctionList.js';\nimport {MathDocument} from '../core/MathDocument.js';\nimport {MathItem} from '../core/MathItem.js';\nimport {DOMAdaptor} from '../core/DOMAdaptor.js';\nimport {MmlFactory} from '../core/MmlTree/MmlFactory.js';\n\nimport {FindMathML} from './mathml/FindMathML.js';\nimport {MathMLCompile} from './mathml/MathMLCompile.js';\n\n/*****************************************************************/\n/**\n *  Implements the MathML class (extends AbstractInputJax)\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class MathML<N, T, D> extends AbstractInputJax<N, T, D> {\n\n  /**\n   * The name of this input jax\n   */\n  public static NAME: string = 'MathML';\n\n  /**\n   * @override\n   */\n  public static OPTIONS: OptionList = defaultOptions({\n    parseAs: 'html',         // Whether to use HTML or XML parsing for the MathML string\n    forceReparse: false,     // Whether to force the string to be reparsed, or use the one from the document DOM\n    FindMathML: null,        // The FindMathML instance to override the default one\n    MathMLCompile: null,     // The MathMLCompile instance to override the default one\n    /*\n     * The function to use to handle a parsing error (throw an error by default)\n     */\n    parseError: function (node: Node) {\n      this.error(this.adaptor.textContent(node).replace(/\\n.*/g, ''));\n    }\n  }, AbstractInputJax.OPTIONS);\n\n  /**\n   * The FindMathML instance used to locate MathML in the document\n   */\n  protected findMathML: FindMathML<N, T, D>;\n\n  /**\n   * The MathMLCompile instance used to convert the MathML tree to internal format\n   */\n  protected mathml: MathMLCompile<N, T, D>;\n\n  /**\n   * A list of functions to call on the parsed MathML DOM before conversion to internal structure\n   */\n  public mmlFilters: FunctionList;\n\n  /**\n   * @override\n   */\n  constructor(options: OptionList = {}) {\n    let [mml, find, compile] = separateOptions(options, FindMathML.OPTIONS, MathMLCompile.OPTIONS);\n    super(mml);\n    this.findMathML = this.options['FindMathML'] || new FindMathML<N, T, D>(find);\n    this.mathml = this.options['MathMLCompile'] || new MathMLCompile<N, T, D>(compile);\n    this.mmlFilters = new FunctionList();\n  }\n\n  /**\n   * Set the adaptor in any of the objects that need it\n   *\n   * @override\n   */\n  public setAdaptor(adaptor: DOMAdaptor<N, T, D>) {\n    super.setAdaptor(adaptor);\n    this.findMathML.adaptor = adaptor;\n    this.mathml.adaptor = adaptor;\n  }\n\n  /**\n   * @param {MmlFactory} mmlFactory  The MmlFactory to use for this MathML input jax\n   */\n  public setMmlFactory(mmlFactory: MmlFactory) {\n    super.setMmlFactory(mmlFactory);\n    this.mathml.setMmlFactory(mmlFactory);\n  }\n\n  /**\n   * Don't process strings (process nodes)\n   *\n   * @override\n   */\n  public get processStrings() {\n    return false;\n  }\n\n  /**\n   * Convert a MathItem to internal format:\n   *   If there is no existing MathML node, or we are asked to reparse everything\n   *     Execute the preFilters on the math\n   *     Parse the MathML string in the desired format, and check the result for errors\n   *     If we got an HTML document:\n   *       Check that it has only one child (the <math> element), and use it\n   *     Otherwise\n   *       Use the root element from the XML document\n   *     If the node is not a <math> node, report the error.\n   *   Execute the mmlFilters on the parsed MathML\n   *   Compile the MathML to internal format, and execute the postFilters\n   *   Return the resulting internal format\n   *\n   * @override\n   */\n  public compile(math: MathItem<N, T, D>, document: MathDocument<N, T, D>) {\n    let mml = math.start.node;\n    if (!mml || !math.end.node || this.options['forceReparse'] || this.adaptor.kind(mml) === '#text') {\n      let mathml = this.executeFilters(this.preFilters, math, document, (math.math || '<math></math>').trim());\n      let doc = this.checkForErrors(this.adaptor.parse(mathml, 'text/' + this.options['parseAs']));\n      let body = this.adaptor.body(doc);\n      if (this.adaptor.childNodes(body).length !== 1) {\n        this.error('MathML must consist of a single element');\n      }\n      mml = this.adaptor.remove(this.adaptor.firstChild(body)) as N;\n      if (this.adaptor.kind(mml).replace(/^[a-z]+:/, '') !== 'math') {\n        this.error('MathML must be formed by a <math> element, not <' + this.adaptor.kind(mml) + '>');\n      }\n    }\n    mml = this.executeFilters(this.mmlFilters, math, document, mml);\n    return this.executeFilters(this.postFilters, math, document, this.mathml.compile(mml as N));\n  }\n\n  /**\n   * Check a parsed MathML string for errors.\n   *\n   * @param {D} doc  The document returns from the DOMParser\n   * @return {D}     The document\n   */\n  protected checkForErrors(doc: D): D {\n    let err = this.adaptor.tags(this.adaptor.body(doc), 'parsererror')[0];\n    if (err) {\n      if (this.adaptor.textContent(err) === '') {\n        this.error('Error processing MathML');\n      }\n      this.options['parseError'].call(this, err);\n    }\n    return doc;\n  }\n\n  /**\n   * Throw an error\n   *\n   * @param {string} message  The error message to produce\n   */\n  protected error(message: string) {\n    throw new Error(message);\n  }\n\n  /**\n   * @override\n   */\n  public findMath(node: N) {\n    return this.findMathML.findMath(node);\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}